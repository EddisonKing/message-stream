package messagestream

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"encoding/json"
	"fmt"
	"io"
	"math"
	"math/big"
	"time"
)

// Message Stream supporting Send and Receive operations.
type MessageStream struct {
	tgtPubKey            *rsa.PublicKey
	pubKey               *rsa.PublicKey
	pubKeyBytes          []byte
	privKey              *rsa.PrivateKey
	sender               io.Writer
	receiver             io.Reader
	output               chan *Message
	errors               chan error
	closed               bool
	receivedNonceHistory map[int]time.Time
	sentNonceHistory     map[int]time.Time
}

// Create a new Message Stream from anything that implements io.ReadWriter.
//
// Returns a reference to the Message Stream, a channel to receive Messages on and a channel to read any errors on.
func New(rw io.ReadWriter) (*MessageStream, error) {
	return NewFrom(rw, rw)
}

// Create a new Message Stream from an individual io.Reader and io.Writer.
//
// Returns a reference to the Message Stream, a channel to receive Messages on and a channel to read any errors on.
func NewFrom(sender io.Writer, receiver io.Reader) (*MessageStream, error) {
	privKey, pubKey := generateRSAKeyPair()
	pubKeyBytes, err := pemEncode(pubKey)
	if err != nil {
		return nil, err
	}

	output := make(chan *Message, 50)
	errs := make(chan error, 30)

	msgStream := &MessageStream{
		pubKey:               pubKey,
		pubKeyBytes:          pubKeyBytes,
		privKey:              privKey,
		sender:               sender,
		receiver:             receiver,
		output:               output,
		closed:               false,
		errors:               errs,
		receivedNonceHistory: make(map[int]time.Time),
		sentNonceHistory:     make(map[int]time.Time),
	}

	// Connect message containing this end's public key
	nonce, err := generateNonce()
	if err != nil {
		return nil, err
	}
	storeNonce(&msgStream.sentNonceHistory, nonce)
	msgStream.sendMessage(createMessageHeader(headerContainsPublicKey, nonce, msgStream.pubKeyBytes, nil), nil)

	// Receive target's public key
	header, _, _ := msgStream.receiveMessage()
	msgStream.tgtPubKey = header.tgtPubKey

	// Consciously ignoring error here as it is impossible at this point to see a repeated nonce
	storeNonce(&msgStream.receivedNonceHistory, header.nonce)

	go func() {
		for !msgStream.closed {
			_, msg, signature := msgStream.receiveMessage()
			msgBytes, err := msg.bytes()
			if err != nil {
				errs <- err
				continue
			}
			if isValid(msgBytes, signature, msgStream.tgtPubKey) {
				output <- msg
			}
		}
	}()

	return msgStream, nil
}

func generateNonce() (int, error) {
	nonce, err := rand.Int(rand.Reader, big.NewInt(int64(math.MaxInt32)))
	if err != nil {
		return 0, err
	}

	return int(nonce.Int64()), nil
}

func (ms *MessageStream) newNonce() (int, error) {
	var n int
	for {
		nonce, err := generateNonce()
		if err != nil {
			return 0, err
		}

		if err = storeNonce(&ms.sentNonceHistory, nonce); err != nil {
			continue
		}

		n = nonce
		break
	}
	return n, nil
}

const nonceTTL time.Duration = time.Minute * 15 // Not sure about the time, this should be relative to the time it might take to randomly generate the same nonce again

func storeNonce(nonceHistory *map[int]time.Time, nonce int) error {
	if seenTime, exists := (*nonceHistory)[nonce]; exists {
		if time.Since(seenTime) < nonceTTL {
			return fmt.Errorf("nonce %d has already been received, this could be a replay", nonce)
		}
	}
	// Refresh or set nonce TTL
	(*nonceHistory)[nonce] = time.Now().UTC()
	return nil
}

// Terminates any internal channels preventing sending and receiving on this Message Stream.
func (ms *MessageStream) Close() {
	ms.closed = true
	close(ms.output)
}

// Sends a Message on the io.Writer portion of the Message Stream.
//
// Returns an error if it fails serialise the metadata or payload, write data to the underlying `io.Writer` or generate a nonce.
func (ms *MessageStream) SendMessage(t MessageType, metadata map[string]any, payload any) error {
	m, err := newMessage(t, metadata, payload)
	if err != nil {
		return err
	}

	n, err := ms.newNonce()
	if err != nil {
		return err
	}

	return ms.sendMessage(createMessageHeader(0, n, nil, ms.tgtPubKey), m)
}

// Forward an existing Message. This is useful in a situation where multiple Message Streams are being used and a received Message needs to be passed to a different Message Stream.
//
// Returns an error if it fails to write data to the underlying `io.Writer` or generate a nonce.
func (ms *MessageStream) ForwardMessage(msg *Message) error {
	n, err := ms.newNonce()
	if err != nil {
		return err
	}

	return ms.sendMessage(createMessageHeader(0, n, nil, ms.tgtPubKey), msg)
}

// Returns a channel where incoming Messages can be received.
func (ms *MessageStream) Receiver() <-chan *Message {
	return ms.output
}

// Returns a channel where any errors generated by the Message Stream's operations will be sent.
func (ms *MessageStream) Errors() <-chan error {
	return ms.errors
}

func (ms *MessageStream) sendMessage(h *messageHeader, m *Message) error {
	b := bytes.NewBuffer(nil)

	b.Write(h.bytes())

	msgBytes, err := m.bytes()
	if err != nil {
		ms.errors <- err
		return nil
	}

	if ms.tgtPubKey != nil {
		encryptedBytes := encrypt(msgBytes, ms.tgtPubKey)
		writeLV(encryptedBytes, b)
		signature := sign(msgBytes, ms.privKey)
		writeLV(signature, b)
	} else {
		writeLV(msgBytes, b)
	}

	if _, err := ms.sender.Write(b.Bytes()); err != nil {
		ms.errors <- err
		return err
	}

	return nil
}

func (ms *MessageStream) reportIfError(data []byte, err error) ([]byte, bool) {
	if err != nil {
		if err != io.EOF {
			ms.errors <- err
		}
		return nil, false
	}
	return data, true
}

func (ms *MessageStream) receiveMessage() (*messageHeader, *Message, []byte) {
	for {
		magicBytes, ok := ms.reportIfError(readV(3, ms.receiver))
		if !ok {
			continue
		}

		if string(magicBytes) != magicStr {
			continue
		}

		flagBytes, ok := ms.reportIfError(readV(1, ms.receiver))
		if !ok {
			continue
		}

		flags := headerFlag(flagBytes[0])

		var tgtPubKey *rsa.PublicKey
		if flags&headerContainsPublicKey == 1 {
			tgtPubKeyBytes, ok := ms.reportIfError(readLV(4, ms.receiver))
			if !ok {
				continue
			}

			pubKey, err := pemDecode(tgtPubKeyBytes)
			if err != nil {
				ms.errors <- err
				continue
			}
			tgtPubKey = pubKey
		}

		nonceBytes, ok := ms.reportIfError(readLV(4, ms.receiver))
		if !ok {
			continue
		}

		if flags.hasHeader(headerEncryptedWithRecipientPublicKey) {
			nonceBytes = decrypt(nonceBytes, ms.privKey)
		}

		nonce := bytesToInt(nonceBytes)

		// Abandoning any messages with a repeated nonce as it may be a replay attack
		if err := storeNonce(&ms.receivedNonceHistory, nonce); err != nil {
			ms.errors <- err
			return nil, nil, nil
		}

		header := &messageHeader{
			tgtPubKey: tgtPubKey,
			nonce:     nonce,
		}

		messageBytes, ok := ms.reportIfError(readLV(4, ms.receiver))
		if !ok || len(messageBytes) == 0 {
			return header, nil, nil
		}

		if flags.hasHeader(headerEncryptedWithRecipientPublicKey) {
			messageBytes = decrypt(messageBytes, ms.privKey)
		}

		messageBuffer := bytes.NewReader(messageBytes)

		msgTypeBytes, ok := ms.reportIfError(readLV(4, messageBuffer))
		if !ok {
			continue
		}
		msgType := MessageType(string(msgTypeBytes))

		metadataBytes, ok := ms.reportIfError(readLV(4, messageBuffer))
		if !ok {
			continue
		}

		var metadata map[string]any
		err := json.Unmarshal(metadataBytes, &metadata)
		if err != nil {
			ms.errors <- err
		}

		payloadBytes, ok := ms.reportIfError(readLV(4, messageBuffer))
		if !ok {
			continue
		}

		signature, ok := ms.reportIfError(readLV(4, ms.receiver))
		if !ok {
			continue
		}

		return header, &Message{
			metadata: metadata,
			Type:     msgType,
			payload:  payloadBytes,
		}, signature
	}
}
